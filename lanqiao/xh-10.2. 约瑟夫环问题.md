https://leetcode.cn/problems/W7yuXW/


```
class Solution
{
public:
    struct node
    {
        int idx;        // 存储 people 数组中的值
        struct node* next;  // 双向链表下一个节点
        struct node* last;  // 双向链表上一个节点
    };

    vector<int> Joseph_circle(vector<int>& people, int k)
    {
        vector<int> out;  // 存储出局顺序
        int remaining = people.size();

        // 构建双向循环链表
        struct node* begin;
        struct node* last;
        for (int i = 0; i < people.size(); i++)
        {
            struct node* new_node = new struct node;
            new_node->idx = people[i];
            if (i == 0)
            {
                begin = new_node;
            }
            else
            {
                last->next = new_node;
                new_node->last = last;
            }
            last = new_node;
        }
        // 连接首尾形成循环链表
        last->next = begin;
        begin->last = last;

        struct node* cur = begin;
        for (int i = 0; i < people.size(); i++)
        {
            remaining = people.size() - i;
            // 关键优化：计算实际需要移动的步数
            // (k-1) % remaining 是因为：
            // - 从当前节点开始数，数到第k个人出局，实际只需要移动 k-1 步
            // - % remaining 避免不必要的循环移动
            int k_ = (k - 1) % remaining;
            
            // 移动到要淘汰的节点
            for (int i = 0; i < k_; i++)
            {
                cur = cur->next;
            }
            
            // 记录淘汰的人
            out.push_back(cur->idx);
            
            if (remaining > 1)
            {
                // 高效删除节点：直接调整指针，O(1)时间
                struct node* ne = cur->next;
                struct node* la = cur->last;
                ne->last = la;
                la->next = ne;
                
                // 移动到下一个开始位置
                cur = ne;
            }
            else
            {
                break;
            }
        }

        return out;
    }
};
```
